* ir1-grapher
  This library graphs SBCL [[https://cmucl.org/docs/internals/html/The-Implicit-Continuation-Representation.html#The-Implicit-Continuation-Representation][ir1]] and outputs graphviz.

  As of now, it is stil unfinished. There are a few tweaks that are
  needed to improve useablility, in particular, I think the rendering
  could be done a lot better, with subgraphs, to make it a lot more
  readable. Also to make it more readable, I'm planning on
  implementing rainbow-parens-esque arrow + label color randomization.

** How do I use it?
   To load the system, you can call ~(asdf:load-system
   :ir1-grapher)~ once you have either loaded ~ir1-grapher.asd~
   manually, or placed the folder inside your [[https://common-lisp.net/project/asdf/asdf/Configuring-ASDF-to-find-your-systems.html][ASDF load path]].

   Then, depending on how you want to use it, you can do a few
   things. If you only want to get output of the entire graph which
   was produced during compilation, then read the following paragraph.
   
   Because of the way it hooks in the compiler, you shouldn't actually
   have to do anything after loading it except turning on trace output
   of the compiler (SBCL). This can be done by calling ~(compile-file
   "file" :trace-file t)~. After compilation is done, alongside the
   normal trace file, SBCL is hooked into writing a series of .dot
   files, which contain the graphviz DOT representation of all the
   components compiled. If you set ~*compile-progress*~ to ~T~, it
   will print out progress information, and will tell you when and
   where it writes out the graphviz files.

   If you ran into a compiler error, and want to graph the
   still-in-memory code interactively, you can do so with the
   following functions:
   
*** ~make-and-bfs~
    This function takes an ir1 object, and integer distance, and
    returns a graph object with the BFS walk encoded in its
    ~bfs-table~. Each object is tagged with a "codename", visible as a
    hex digit in braces at the start of each graph node.
    
    Then, to operate on the graph interactively, you can use:

    
*** ~interactively-graph~
    This function takes a graph object, and sets the current working
    graph to it.
    
*** ~output~
    This function outputs the current working graph to a string, and
    if passed a filename, writes it to that file.
    
*** ~expand~
    After you've rendered the graph, if you want to add a node to the
    bfs-table (thus expanding the amount of the in-memory objects
    rendered), call this function with the codename of the new object
    you'd like to add. Example: ~(expand "A")~.

    Subsequent calls to ~output~ will then render that node as well.

    
*** ~render-graph~
    Given a graph with objects in its ~bfs-table~, returns a string of
    the rendering of the graph in DOT.

    Does the same thing as ~output~, but non-interactively. It takes a
    graph as a parameter.

*** ~expand-graph-codename~
    Does the same thing as ~expand~, but non-interactively. It takes a
    graph and codename as parameter.

** Help! It's saying there's a package locking error.
   Run ~(sb-ext:unlock-package :sb-c)~ in the REPL, or compile SBCL
   with ~--with-sb-devel~ (if you're doing compiler work, you should
   probably do this anyways). In ~src/package.lisp~, there's a
   ~(sb-ext:unlock-package :sb-c)~ statement, but it seems to not work
   as expected. 

** But what if the compiler breaks your library, or I want to muck around with it?
   ~hooking.lisp~ contains all the code that is used to hook the
   compiler directly, and ~graphing.lisp~ goes from the compiler data
   structures to the graphviz DOT format.

   Right now, I'm assuming that the only place that the compiler will
   ever call ~sb-c::ir2-convert~ for each component is inside
   ~%compile-component~, and only one time. If this becomes no longer
   true, then the hooking location/manner will have to be modified.

** After the ~.dot~ files get output, how do I render them?
   ~dot -T<output-format> input.dot > output~.
   For example, ~dot -Tsvg trace-1-DEFUNFOO.dot > out.svg~.
  
** Can I see an example?
   Yes, look at the ~example/~ folder. It contains the dot output
   when running ~(compile-file "testfile" :trace-file t)~.
